package com.entity.wtv.service;

import com.entity.wtv.dto.*;
import com.entity.wtv.entity.Entmonth;
import com.entity.wtv.exception.ResourceNotFoundException;
import com.entity.wtv.repository.EntmonthRepository;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.DayOfWeek;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.time.temporal.TemporalAdjusters;
import java.util.*;
import java.util.stream.Collectors;

/**
 * Service for CTRS Calendar functionality
 * 
 * Manages fiscal years (October - September) and their monthly periods
 */
@Service
@RequiredArgsConstructor
@Slf4j
@Transactional(readOnly = true)
public class CtrsCalendarService {

    private final EntmonthRepository entmonthRepository;
    private final ObjectMapper objectMapper;

    // Fiscal year month order (October to September)
    private static final String[] FISCAL_MONTH_ORDER = {
        "OCT", "NOV", "DEC", "JAN", "FEB", "MAR", 
        "APR", "MAY", "JUN", "JUL", "AUG", "SEP"
    };

    private static final LocalDate DEFAULT_RPTNATIONAL = LocalDate.of(1900, 1, 1);

    // =========================================================================
    // GET Operations
    // =========================================================================

    /**
     * Get list of all available fiscal years
     */
    public List<Integer> getAllFiscalYears() {
        log.info("Getting all fiscal years");
        return entmonthRepository.findDistinctFiscalYears();
    }

    /**
     * Get list of active fiscal years only
     */
    public List<Integer> getActiveFiscalYears() {
        log.info("Getting active fiscal years");
        return entmonthRepository.findActiveFiscalYears();
    }

    /**
     * Get complete fiscal year with all months
     */
    public FiscalYearDTO getFiscalYear(Integer year) {
        log.info("Getting fiscal year: {}", year);
        
        List<Entmonth> months = getFiscalYearMonths(year);
        
        if (months.isEmpty()) {
            throw new ResourceNotFoundException("Fiscal year " + year + " not found");
        }

        return buildFiscalYearDTO(year, months);
    }

    /**
     * Get a single fiscal month with week details
     */
    public FiscalMonthDTO getFiscalMonth(String rptMonth) {
        log.info("Getting fiscal month: {}", rptMonth);
        
        Entmonth month = entmonthRepository.findByRptmonth(rptMonth.toUpperCase())
            .orElseThrow(() -> new ResourceNotFoundException("Month " + rptMonth + " not found"));
        
        return toFiscalMonthDTO(month);
    }

    // =========================================================================
    // CREATE Operations
    // =========================================================================

    /**
     * Create a new fiscal year
     * Supports:
     * - Auto-generation with calculated dates
     * - Empty creation (user fills in later)
     * - Copy from previous year
     */
    @Transactional
    public FiscalYearDTO createFiscalYear(CreateFiscalYearRequest request) {
        log.info("Creating fiscal year: {}, empty={}, copyFromPrevious={}", 
                request.getFiscalYear(), request.getEmpty(), request.getCopyFromPrevious());
        
        Integer year = request.getFiscalYear();
        
        // Check if already exists
        if (existsFiscalYear(year)) {
            throw new IllegalArgumentException("Fiscal year " + year + " already exists");
        }

        List<Entmonth> generatedMonths;

        if (Boolean.TRUE.equals(request.getEmpty())) {
            // Create empty structure - user will fill in data
            generatedMonths = createEmptyFiscalYear(year);
        } else if (Boolean.TRUE.equals(request.getCopyFromPrevious())) {
            // Copy from previous/source year
            Integer sourceYear = request.getSourceYear() != null ? request.getSourceYear() : year - 1;
            generatedMonths = copyFromPreviousFiscalYear(year, sourceYear);
        } else {
            // Auto-generate with calculated dates
            generatedMonths = createAutoGeneratedFiscalYear(year, request.getStartDate());
        }

        // Save all months
        entmonthRepository.saveAll(generatedMonths);
        log.info("Created {} months for fiscal year {}", generatedMonths.size(), year);

        return getFiscalYear(year);
    }

    /**
     * Create empty fiscal year structure
     */
    private List<Entmonth> createEmptyFiscalYear(Integer year) {
        List<Entmonth> months = new ArrayList<>();
        int cycleNumber = year * 100 + 1;

        for (String monthAbbrev : FISCAL_MONTH_ORDER) {
            int calendarYear = monthAbbrev.matches("OCT|NOV|DEC") ? year - 1 : year;
            String rptMonth = monthAbbrev + calendarYear;

            Entmonth month = Entmonth.builder()
                .rptmonth(rptMonth)
                .startdt(null)  // Empty - user fills in
                .enddt(null)
                .weeks(4)       // Default to 4 weeks
                .startcyc(cycleNumber)
                .endcyc(cycleNumber + 3)
                .workdays(20)   // Default: 4 weeks * 5 days
                .holidays(0)
                .hours(20)      // Default hours
                .rptnational(DEFAULT_RPTNATIONAL)
                .active("Y")
                .build();

            months.add(month);
            cycleNumber += 4;
        }

        return months;
    }

    /**
     * Copy structure from a previous fiscal year
     */
    private List<Entmonth> copyFromPreviousFiscalYear(Integer targetYear, Integer sourceYear) {
        List<Entmonth> sourceMonths = getFiscalYearMonths(sourceYear);
        
        if (sourceMonths.isEmpty()) {
            throw new ResourceNotFoundException("Source fiscal year " + sourceYear + " not found");
        }

        List<Entmonth> newMonths = new ArrayList<>();
        int yearDiff = targetYear - sourceYear;

        for (Entmonth source : sourceMonths) {
            String monthAbbrev = source.getMonthAbbrev();
            int calendarYear = monthAbbrev.matches("OCT|NOV|DEC") ? targetYear - 1 : targetYear;
            String rptMonth = monthAbbrev + calendarYear;

            // Shift dates by the year difference
            LocalDate newStartDt = source.getStartdt() != null ? 
                source.getStartdt().plusYears(yearDiff) : null;
            LocalDate newEndDt = source.getEnddt() != null ? 
                source.getEnddt().plusYears(yearDiff) : null;

            // Shift cycle numbers
            int cycleShift = yearDiff * 100;

            Entmonth newMonth = Entmonth.builder()
                .rptmonth(rptMonth)
                .startdt(newStartDt)
                .enddt(newEndDt)
                .weeks(source.getWeeks())
                .startcyc(source.getStartcyc() != null ? source.getStartcyc() + cycleShift : null)
                .endcyc(source.getEndcyc() != null ? source.getEndcyc() + cycleShift : null)
                .workdays(source.getWorkdays())
                .holidays(source.getHolidays())
                .hours(source.getHours())
                .rptnational(DEFAULT_RPTNATIONAL)
                .active("Y")
                .weekData(source.getWeekData())  // Copy week-level data
                .build();

            newMonths.add(newMonth);
        }

        return newMonths;
    }

    /**
     * Create auto-generated fiscal year with calculated dates
     */
    private List<Entmonth> createAutoGeneratedFiscalYear(Integer year, LocalDate providedStartDate) {
        // Determine start date (first Sunday on or before Oct 1)
        LocalDate startDate = providedStartDate;
        if (startDate == null) {
            LocalDate oct1 = LocalDate.of(year - 1, 10, 1);
            startDate = oct1.with(TemporalAdjusters.previousOrSame(DayOfWeek.SUNDAY));
        }

        List<Entmonth> generatedMonths = new ArrayList<>();
        LocalDate currentStart = startDate;
        int cycleNumber = year * 100 + 1;

        for (String monthAbbrev : FISCAL_MONTH_ORDER) {
            int calendarYear = monthAbbrev.matches("OCT|NOV|DEC") ? year - 1 : year;
            String rptMonth = monthAbbrev + calendarYear;

            int weeks = calculateWeeksForMonth(monthAbbrev, calendarYear);
            LocalDate endDate = currentStart.plusDays((weeks * 7L) - 1);
            int workdays = weeks * 5;

            // Generate week-level data
            String weekData = generateWeekDataJson(currentStart, weeks, cycleNumber);

            Entmonth month = Entmonth.builder()
                .rptmonth(rptMonth)
                .startdt(currentStart)
                .enddt(endDate)
                .weeks(weeks)
                .startcyc(cycleNumber)
                .endcyc(cycleNumber + weeks - 1)
                .workdays(workdays)
                .holidays(0)
                .hours(workdays)
                .rptnational(DEFAULT_RPTNATIONAL)
                .active("Y")
                .weekData(weekData)
                .build();

            generatedMonths.add(month);
            currentStart = endDate.plusDays(1);
            cycleNumber += weeks;
        }

        return generatedMonths;
    }

    // =========================================================================
    // UPDATE Operations
    // =========================================================================

    /**
     * Update a single fiscal month
     */
    @Transactional
    public FiscalMonthDTO updateFiscalMonth(String rptMonth, UpdateFiscalMonthRequest request) {
        log.info("Updating fiscal month: {}", rptMonth);
        
        Entmonth month = entmonthRepository.findByRptmonth(rptMonth.toUpperCase())
            .orElseThrow(() -> new ResourceNotFoundException("Month " + rptMonth + " not found"));

        // Update month-level fields if provided
        if (request.getStartDate() != null) {
            month.setStartdt(request.getStartDate());
        }
        if (request.getEndDate() != null) {
            month.setEnddt(request.getEndDate());
        }
        if (request.getWeeks() != null) {
            month.setWeeks(request.getWeeks());
        }
        if (request.getStartCycle() != null) {
            month.setStartcyc(request.getStartCycle());
        }
        if (request.getEndCycle() != null) {
            month.setEndcyc(request.getEndCycle());
        }
        if (request.getWorkdays() != null) {
            month.setWorkdays(request.getWorkdays());
        }
        if (request.getHolidays() != null) {
            month.setHolidays(request.getHolidays());
        }
        if (request.getHours() != null) {
            month.setHours(request.getHours());
        }

        // Update week-level data if provided
        if (request.getWeekUpdates() != null && !request.getWeekUpdates().isEmpty()) {
            updateWeekData(month, request.getWeekUpdates());
        }

        entmonthRepository.save(month);
        log.info("Updated month: {}", rptMonth);

        return toFiscalMonthDTO(month);
    }

    /**
     * Update week-level data within a month
     */
    private void updateWeekData(Entmonth month, List<UpdateFiscalMonthRequest.WeekUpdateDTO> weekUpdates) {
        List<Map<String, Object>> existingWeeks = parseWeekData(month.getWeekData());
        
        for (UpdateFiscalMonthRequest.WeekUpdateDTO update : weekUpdates) {
            // Find the week to update
            Optional<Map<String, Object>> weekToUpdate = existingWeeks.stream()
                .filter(w -> update.getCycleNumber().equals(w.get("cycle")))
                .findFirst();

            if (weekToUpdate.isPresent()) {
                Map<String, Object> week = weekToUpdate.get();
                if (update.getWorkdays() != null) week.put("workdays", update.getWorkdays());
                if (update.getHolidays() != null) week.put("holidays", update.getHolidays());
                if (update.getHours() != null) week.put("hours", update.getHours());
            }
        }

        // Recalculate month totals from weeks
        int totalWorkdays = existingWeeks.stream()
            .mapToInt(w -> (Integer) w.getOrDefault("workdays", 5))
            .sum();
        int totalHolidays = existingWeeks.stream()
            .mapToInt(w -> (Integer) w.getOrDefault("holidays", 0))
            .sum();
        int totalHours = existingWeeks.stream()
            .mapToInt(w -> (Integer) w.getOrDefault("hours", 40))
            .sum();

        month.setWorkdays(totalWorkdays);
        month.setHolidays(totalHolidays);
        month.setHours(totalHours);
        month.setWeekData(serializeWeekData(existingWeeks));
    }

    /**
     * Bulk update all months in a fiscal year
     */
    @Transactional
    public FiscalYearDTO updateFiscalYear(Integer year, List<UpdateFiscalMonthRequest> monthUpdates) {
        log.info("Bulk updating fiscal year: {} with {} month updates", year, monthUpdates.size());
        
        for (UpdateFiscalMonthRequest update : monthUpdates) {
            if (update.getRptMonth() != null) {
                updateFiscalMonth(update.getRptMonth(), update);
            }
        }

        return getFiscalYear(year);
    }

    /**
     * Mark fiscal year as inactive
     */
    @Transactional
    public FiscalYearDTO markFiscalYearInactive(Integer year) {
        log.info("Marking fiscal year {} as inactive", year);
        
        String yearStr = String.valueOf(year);
        
        if (!existsFiscalYear(year)) {
            throw new ResourceNotFoundException("Fiscal year " + year + " not found");
        }

        int updated = entmonthRepository.updateActiveStatusByFiscalYear(yearStr, "N");
        log.info("Marked {} months as inactive for fiscal year {}", updated, year);

        return getFiscalYear(year);
    }

    /**
     * Mark fiscal year as active
     */
    @Transactional
    public FiscalYearDTO markFiscalYearActive(Integer year) {
        log.info("Marking fiscal year {} as active", year);
        
        String yearStr = String.valueOf(year);
        
        if (!existsFiscalYear(year)) {
            throw new ResourceNotFoundException("Fiscal year " + year + " not found");
        }

        int updated = entmonthRepository.updateActiveStatusByFiscalYear(yearStr, "Y");
        log.info("Marked {} months as active for fiscal year {}", updated, year);

        return getFiscalYear(year);
    }

    // =========================================================================
    // DELETE Operations
    // =========================================================================

    /**
     * Delete an entire fiscal year
     */
    @Transactional
    public void deleteFiscalYear(Integer year) {
        log.info("Deleting fiscal year: {}", year);
        
        String yearStr = String.valueOf(year);
        
        if (!existsFiscalYear(year)) {
            throw new ResourceNotFoundException("Fiscal year " + year + " not found");
        }

        // TODO: Add check for existing time entries before deleting
        
        int deleted = entmonthRepository.deleteByFiscalYear(yearStr);
        log.info("Deleted {} months for fiscal year {}", deleted, year);
    }

    // =========================================================================
    // Helper Methods
    // =========================================================================

    /**
     * Check if fiscal year exists
     */
    private boolean existsFiscalYear(Integer year) {
        // Need to check both calendar years for a fiscal year
        // FY2026 = OCT2025, NOV2025, DEC2025, JAN2026-SEP2026
        String prevYear = String.valueOf(year - 1);
        String currYear = String.valueOf(year);
        
        return entmonthRepository.existsByFiscalYear(prevYear) || 
               entmonthRepository.existsByFiscalYear(currYear);
    }

    /**
     * Get all months for a fiscal year
     */
    private List<Entmonth> getFiscalYearMonths(Integer year) {
        // FY2026 includes: OCT2025, NOV2025, DEC2025, JAN2026-SEP2026
        String prevYear = String.valueOf(year - 1);
        String currYear = String.valueOf(year);
        
        List<Entmonth> prevYearMonths = entmonthRepository.findByFiscalYearPattern(prevYear);
        List<Entmonth> currYearMonths = entmonthRepository.findByFiscalYearPattern(currYear);
        
        // Combine and filter to just the fiscal year months
        List<Entmonth> allMonths = new ArrayList<>();
        
        // Add OCT, NOV, DEC from previous calendar year
        prevYearMonths.stream()
            .filter(m -> {
                String abbrev = m.getMonthAbbrev();
                return "OCT".equals(abbrev) || "NOV".equals(abbrev) || "DEC".equals(abbrev);
            })
            .forEach(allMonths::add);
        
        // Add JAN-SEP from current calendar year
        currYearMonths.stream()
            .filter(m -> {
                String abbrev = m.getMonthAbbrev();
                return !"OCT".equals(abbrev) && !"NOV".equals(abbrev) && !"DEC".equals(abbrev);
            })
            .forEach(allMonths::add);
        
        // Sort in fiscal year order
        allMonths.sort((a, b) -> {
            int orderA = getFiscalMonthOrder(a.getMonthAbbrev());
            int orderB = getFiscalMonthOrder(b.getMonthAbbrev());
            return Integer.compare(orderA, orderB);
        });
        
        return allMonths;
    }

    /**
     * Get fiscal month order (OCT=1, NOV=2, ..., SEP=12)
     */
    private int getFiscalMonthOrder(String monthAbbrev) {
        return switch (monthAbbrev) {
            case "OCT" -> 1;
            case "NOV" -> 2;
            case "DEC" -> 3;
            case "JAN" -> 4;
            case "FEB" -> 5;
            case "MAR" -> 6;
            case "APR" -> 7;
            case "MAY" -> 8;
            case "JUN" -> 9;
            case "JUL" -> 10;
            case "AUG" -> 11;
            case "SEP" -> 12;
            default -> 13;
        };
    }

    /**
     * Build FiscalYearDTO from months
     */
    private FiscalYearDTO buildFiscalYearDTO(Integer year, List<Entmonth> months) {
        List<FiscalMonthDTO> monthDTOs = months.stream()
            .map(this::toFiscalMonthDTO)
            .collect(Collectors.toList());

        int totalWeeks = months.stream()
            .mapToInt(m -> m.getWeeks() != null ? m.getWeeks() : 0)
            .sum();

        int totalWorkdays = months.stream()
            .mapToInt(m -> m.getWorkdays() != null ? m.getWorkdays() : 0)
            .sum();

        int totalHolidays = months.stream()
            .mapToInt(m -> m.getHolidays() != null ? m.getHolidays() : 0)
            .sum();

        int totalHours = months.stream()
            .mapToInt(m -> m.getHours() != null ? m.getHours() : 0)
            .sum();

        boolean isActive = months.stream().anyMatch(Entmonth::isActive);
        String status = isActive ? "Active" : "Inactive";

        return FiscalYearDTO.builder()
            .fiscalYear(year)
            .displayLabel(String.valueOf(year))
            .totalWeeks(totalWeeks)
            .totalWorkdays(totalWorkdays)
            .totalHolidays(totalHolidays)
            .totalHours(totalHours)
            .months(monthDTOs)
            .active(isActive)
            .status(status)
            .build();
    }

    /**
     * Convert Entmonth entity to FiscalMonthDTO
     */
    private FiscalMonthDTO toFiscalMonthDTO(Entmonth entity) {
        List<FiscalMonthDTO.WeekCycleDTO> weeks = generateWeekCycles(entity);
        String dateRange = formatDateRange(entity.getStartdt(), entity.getEnddt());

        return FiscalMonthDTO.builder()
            .rptMonth(entity.getRptmonth())
            .monthName(entity.getMonthName())
            .postingCycles(entity.getWeeks())
            .startDate(entity.getStartdt())
            .endDate(entity.getEnddt())
            .dateRange(dateRange)
            .workdays(entity.getWorkdays())
            .holidays(entity.getHolidays() != null ? entity.getHolidays() : 0)
            .hours(entity.getHours() != null ? entity.getHours() : entity.getWorkdays())
            .startCycle(entity.getStartcyc())
            .endCycle(entity.getEndcyc())
            .weeks(weeks)
            .rptNational(entity.getRptnational())
            .expandable(true)
            .build();
    }

    /**
     * Generate individual week cycles for a month
     */
    private List<FiscalMonthDTO.WeekCycleDTO> generateWeekCycles(Entmonth month) {
        List<FiscalMonthDTO.WeekCycleDTO> weeks = new ArrayList<>();
        
        // First try to use stored week data
        List<Map<String, Object>> storedWeekData = parseWeekData(month.getWeekData());
        
        if (!storedWeekData.isEmpty()) {
            int weekNum = 1;
            for (Map<String, Object> weekMap : storedWeekData) {
                weeks.add(FiscalMonthDTO.WeekCycleDTO.builder()
                    .cycleNumber((Integer) weekMap.get("cycle"))
                    .weekNumber(weekNum++)
                    .startDate(parseDate(weekMap.get("startDate")))
                    .endDate(parseDate(weekMap.get("endDate")))
                    .dateRange((String) weekMap.get("dateRange"))
                    .workdays((Integer) weekMap.getOrDefault("workdays", 5))
                    .holidays((Integer) weekMap.getOrDefault("holidays", 0))
                    .hours((Integer) weekMap.getOrDefault("hours", 40))
                    .build());
            }
            return weeks;
        }

        // Fall back to generating from month data
        if (month.getStartdt() == null || month.getStartcyc() == null || month.getWeeks() == null) {
            return weeks;
        }

        LocalDate weekStart = month.getStartdt();
        int cycleNum = month.getStartcyc();

        for (int i = 0; i < month.getWeeks(); i++) {
            LocalDate weekEnd = weekStart.plusDays(6);
            
            weeks.add(FiscalMonthDTO.WeekCycleDTO.builder()
                .cycleNumber(cycleNum)
                .weekNumber(i + 1)
                .startDate(weekStart)
                .endDate(weekEnd)
                .dateRange(formatWeekDateRange(weekStart, weekEnd))
                .workdays(5)
                .holidays(0)
                .hours(5)  // Default: 5 hours display (matches UI screenshot)
                .build());

            weekStart = weekEnd.plusDays(1);
            cycleNum++;
        }

        return weeks;
    }

    /**
     * Generate week data JSON for storage
     */
    private String generateWeekDataJson(LocalDate monthStart, int numWeeks, int startCycle) {
        List<Map<String, Object>> weeks = new ArrayList<>();
        LocalDate weekStart = monthStart;

        for (int i = 0; i < numWeeks; i++) {
            LocalDate weekEnd = weekStart.plusDays(6);
            
            Map<String, Object> week = new LinkedHashMap<>();
            week.put("cycle", startCycle + i);
            week.put("startDate", weekStart.toString());
            week.put("endDate", weekEnd.toString());
            week.put("dateRange", formatWeekDateRange(weekStart, weekEnd));
            week.put("workdays", 5);
            week.put("holidays", 0);
            week.put("hours", 5);
            
            weeks.add(week);
            weekStart = weekEnd.plusDays(1);
        }

        return serializeWeekData(weeks);
    }

    /**
     * Parse week data JSON
     */
    private List<Map<String, Object>> parseWeekData(String weekDataJson) {
        if (weekDataJson == null || weekDataJson.isBlank()) {
            return new ArrayList<>();
        }
        try {
            return objectMapper.readValue(weekDataJson, new TypeReference<List<Map<String, Object>>>() {});
        } catch (JsonProcessingException e) {
            log.warn("Failed to parse week data JSON: {}", e.getMessage());
            return new ArrayList<>();
        }
    }

    /**
     * Serialize week data to JSON
     */
    private String serializeWeekData(List<Map<String, Object>> weeks) {
        try {
            return objectMapper.writeValueAsString(weeks);
        } catch (JsonProcessingException e) {
            log.warn("Failed to serialize week data: {}", e.getMessage());
            return "[]";
        }
    }

    /**
     * Parse date from stored format
     */
    private LocalDate parseDate(Object dateObj) {
        if (dateObj == null) return null;
        if (dateObj instanceof LocalDate) return (LocalDate) dateObj;
        try {
            return LocalDate.parse(dateObj.toString());
        } catch (Exception e) {
            return null;
        }
    }

    /**
     * Format date range for display (e.g., "Sep 29 - Oct 26")
     */
    private String formatDateRange(LocalDate start, LocalDate end) {
        if (start == null || end == null) return "";
        DateTimeFormatter fmt = DateTimeFormatter.ofPattern("MMM d");
        return start.format(fmt) + " - " + end.format(fmt);
    }

    /**
     * Format week date range for display (e.g., "September 29 - October 3")
     */
    private String formatWeekDateRange(LocalDate start, LocalDate end) {
        if (start == null || end == null) return "";
        DateTimeFormatter fmt = DateTimeFormatter.ofPattern("MMMM d");
        return start.format(fmt) + " - " + end.format(fmt);
    }

    /**
     * Calculate number of weeks for a fiscal month
     */
    private int calculateWeeksForMonth(String monthAbbrev, int calendarYear) {
        // Simplified: March, June, September, December have 5 weeks
        return switch (monthAbbrev) {
            case "MAR", "JUN", "SEP", "DEC" -> 5;
            default -> 4;
        };
    }
}
